::Its better to document language related thing here rather than using docx.

* EDA PlayGround

** during simulation when segmentation fault is encountred , then logout from there and relogin.The cause may be because of corupted DB. 



* UVM

** uvm_resource_db : 

*** New configuratoin is added 

**** Providing the scope to where the configuration will be changed.

**** Provide the referencing name . This name 

*** Difference between uvm_config_db and uvm_resource_db

**** When we use uvm_resource_db , we only provide the scope where configuration will be used. While in uvm_config_db we provide the instance name and field whose configuration will be changed.
**** check downloaded paper in downloaded folder 
**** scope field in uvm_resource_db is just string scope which is user defined. When read_by_type is is used then ther can only be one resource under that scaope.
** uvm_sequence
*** Since uvm_sequence is not a uvm_component. uvm_config_db cannot be used to configure its sequence.
*** For configuring uvm_sequence , u first need to get the handle of the sequencer.
** uvm_field_macro
*** Has atleast two argunments ARG and FLAG
*** UVM_ALL_ON - this flag allow the variable to use all the utility methods.
    
    




* TODO Prepare Driver to broad cast packets. Intialize analysis port inside Driver 

** declare analysis port

** create analysis port during build phase

** In run phase write to the port.

** connect this analysis port with driver inside agent.

** Connect this analysis port with SB inside env.

* Monitor

** Decalre anlysis port.

** call new from for this analysis port in build phase.

** Display the content of thsi captured packet during reporting phase and run phase.

** If monitor does not implement write() then it should be made passthrough.. using _export.



* TODO Suscribe monitor and Initialize suscriber port inside scoreboard and monitor

** Connect with driver at env.

* TODO For now just dispaly the content of the packet from scsoreboard and monitor

* TODO Create output interface of the adder.

* TODO Packet modifier

** Packing and Unpacking Fields

** Comparing after packing recieved data.

* TODO Measuring Coverage.
* TODO Attach passive agent to the o/p i/f . Create monitor inside it.

* TODO Create analysis port in passive agent monitor and publis it to the suscribing scoreboard.

* TODO Next make the o/p agent reactive , by sending some response back to the i/p agent

* TODO Run multiple sequence on the same driver. Manage multiple sequence.



* TODO create Packet classs

** Create class by extending uvm_sequence_item.

** Register class and all the fields to DB using uvm_object_utils

** Inside `uvm_object_utils begin-end block define switches for each of the field that will allow which all field methods to work with it.

** Declare packet field using rand key word.

** Provide Constraint to be solved by constraint solver.

** Define new method().

** TODO Example path









* Create program block or test top extnding uvm_test

** Verify packing and unpacking methods by unpacking a packet and then claing method from different packet.


* TODO create ScoreBoard

** To differentiate b/w sent and rcieved implentation method make use of folowing macro
`uvm_analysis_imp_decl(_rcvd_pkt)//Use this preifx to resolve any ambiguity with sent packet.
`uvm_analysis_imp_decl(_sent_pkt) // Use this prefix with sent pkt
Recieved imp will be write_rcvd_pkt
Sent imp will be write_sent_pkt

** Declare two analysis port , one for recieved and the other for sent.

** Implemt the port methods with above prefix.

** For in order recival of packet use que

*** push into que when new packet is sent.

*** pop from que 

* TODO create coverage class

* TODO Test

** Extend test from uvm_test

** Register test to factory

** Declare required components .

** Define function new.

** Define build task.

*** Use create to build components.

*** Use uvm_config_db to alter properties of the components.

*** Create virtual sequencer , and set default sequnce of original sequencer to null.

** Define connect task.


* FACTORY



**  utils_macro -- creates proxy class for defined component--- Proky registers itself to the factory --- factory registry -- associative array indexed by string type name, typed base proxy, -- factory implements overide methods -- create is a method from proxy , gets handle to factory and use the updated proxy class .



** uvm_config_db maintains its own list of symbols.
   -- since instance name does not change when any component is overidden , this works independent of any overide . 
NOTE: uvm_resource_db compared to uvm_config_db does not use uvm_component argument and this facilates it to be retrieved from any where in the environment.Comparitively uvm_config_db uses hierarchy name , which constrains get() to be used from right component.

uvm_config_db #(uvm_object_wrapper)::set(this, "r_agt.sqr.reset_phase", "default_sequence", reset_sequence::get_type());
uvm_config_db #(uvm_object_wrapper)::set(this, {i_agt[i].get_name(), ".", "sqr.reset_phase"}, "default_sequence", router_input_port_reset_sequence::get_type());
uvm_config_db #(int)::set(this, i_agt[i].get_name(), "port_id", i);

* DRIVER

** i/f -- id -- registeration -- new - build_phase -- get i/f - get config -- start_sim_phase - check config - run_phase - get_next_item -- send -- item_done()

* MONITOR

** i/f - id -- registration 
    wait (vif.iMonClk.frame_n[port_id] !==0);
    @(vif.iMonClk iff (vif.iMonClk.frame_n[port_id] === 

* TEST

** Build phase 

* CAllBACKS
  
* PORTS
 i_agt[i].analysis_port.connect(sb.before_export);

* PHASES 
Phases which allows delay are task_based and which does not are function based. 

* SSEQUENCERS 

* SEQUENCES
Most of the cases there will be only one sequence running on the sequencer. All the sequences must be formed inside theis single sequences.
Single sequence can be used to generate all the sequnces for the .

`uvm_do method can be forked to run sequences parallely.

Extending Sequence and using overide methods.
Required types of sequences :

* RAL

** uvm_reg_block (Register Block)

*** create, configure, build

*** reg_map

** uvm_reg

** uvm_reg_sequence

*** 
